<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/@mapbox/mapbox-sdk/umd/mapbox-sdk.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@rtirl/api@latest/lib/index.min.js"></script>
    <script defer src="https://overlays.rtirl.com/indicator.js"></script> 
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans&display=swap" rel="stylesheet">
    <style>
      body {
        background-color: rgba(0, 0, 0, 0);
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      #text {
        color: rgba(223, 251, 38, 1);
        font-size: 46px;
        font-family: 'Open Sans', sans-serif;
        font-weight: normal;
        font-style: normal;
        transform: rotate(0deg);
        background-color: rgba(0, 0, 0, 0);
        border-color: rgba(223, 251, 38, 1);
        border-width: 0px;
        border-style: solid;
        text-align: center;
        border-radius: 0% 0% 0% 0%;
        padding: 0px;
        -webkit-text-stroke-width: 0px;
        -webkit-text-stroke-color: rgba(255, 255, 255, 1);
        text-shadow: 0px 0px 4px rgba(0, 0, 0, 1);
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%; 
      }
    </style>
  </head>
  <body>
    <div id="text">Loading location...</div>

    <script>
      function wrappedEval(textExpression, contextData) {
        let fn = Function(
          `"use strict"; var data = this;return (${textExpression})`
        );
        return fn.bind(contextData)();
      }

      var mapboxClient = mapboxSdk({
        accessToken: "pk.eyJ1IjoiY3diZWFzbGV5IiwiYSI6ImNtYmE3cDhwcjAzNGQycnNhYWFwem0zNWsifQ.IpKDT3XxpNAbvwc8ovez3w",
      });

      var params = new URLSearchParams(window.location.search);
      var pullKey = params.get("key"); 

      // Updated specificFormat to include secondary_address first for smallest to largest flow
      var specificFormat = "${data.secondary_address ? data.secondary_address.text + ', ' : ''}${data.address ? data.address.text + ', ' : ''}${data.neighborhood ? data.neighborhood.text + ', ' : ''}${data.locality ? data.locality.text + ', ' : ''}${data.place ? data.place.text : ''}";
      var specificLang = "en";

      let lastGeocodeTime = 0;
      const geocodeInterval = 1500; 

      if (!pullKey) {
        document.getElementById("text").innerText = "Error: Key missing from URL.";
        console.error("Pull key is missing from URL parameters.");
      } else {
        RealtimeIRL.forPullKey(pullKey).addLocationListener(function (location) {
          const currentTime = new Date().getTime();
          
          if (currentTime - lastGeocodeTime > geocodeInterval) {
            lastGeocodeTime = currentTime; 

            mapboxClient.geocodingV6
              .reverseGeocode({
                longitude: location.longitude,
                latitude: location.latitude,
                language: specificLang,
                // You can request specific types to potentially get secondary_address if available
                types: ["address", "secondary_address", "neighborhood", "locality", "place", "district", "region", "postcode", "country"]
              })
              .send()
              .then((response) => {
                var context = {};
                // Added "secondary_address" to the list of parameters to extract.
                // The order here is just for extraction; display order is controlled by specificFormat.
                const featureParamsToExtract = [
                  "secondary_address", "address", "neighborhood", "locality", "place", 
                  "district", "region", "postcode", "country"
                ];

                for (var param of featureParamsToExtract) {
                  if (response.body && response.body.features) {
                    context[param] = response.body.features.find((feature) =>
                      feature.place_type && feature.place_type.includes(param)
                    );
                  } else {
                    context[param] = undefined;
                  }
                }
                
                var result = wrappedEval(
                  "`" + specificFormat + "`",
                  context
                );

                let cleanedResult = result.trim();
                if (cleanedResult.startsWith(',')) cleanedResult = cleanedResult.substring(1).trim();
                if (cleanedResult.endsWith(',')) cleanedResult = cleanedResult.slice(0, -1).trim();
                cleanedResult = cleanedResult.replace(/,(\s*,)+/g, ',').replace(/,\s*$/, "");

                if (cleanedResult && !cleanedResult.includes("undefined") && cleanedResult.replace(/,/g, "").trim() !== "") { 
                  document.getElementById("text").innerText = cleanedResult;
                 } else {
                  document.getElementById("text").innerText = "Location details not found";
                 }
              })
              .catch(error => {
                  console.error("Mapbox Geocoding v6 error:", error);
                  document.getElementById("text").innerText = "Geocoding API Error";
              });
          }
        });
      }
    </script>
  </body>
</html>