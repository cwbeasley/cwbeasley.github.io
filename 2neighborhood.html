<!DOCTYPE html>
<html>
  <head>
    <title>Google Reverse Geocoding Overlay</title>
    <!-- RealtimeIRL for location data -->
    <script src="https://cdn.jsdelivr.net/npm/@rtirl/api@latest/lib/index.min.js"></script>
    <script src="https://overlays.rtirl.com/indicator.js"></script>  
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans&display=swap" rel="stylesheet">
    <style>
      body {
        background-color: rgba(0, 0, 0, 0);
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      #text {
        color: rgba(223, 251, 38, 1);
        font-size: 46px;
        font-family: 'Open Sans', sans-serif;
        font-weight: normal;
        font-style: normal;
        transform: rotate(0deg);
        background-color: rgba(0, 0, 0, 0);
        border-color: rgba(223, 251, 38, 1);
        border-width: 0px;
        border-style: solid;
        text-align: center;
        border-radius: 0% 0% 0% 0%;
        padding: 0px;
        -webkit-text-stroke-width: 0px;
        -webkit-text-stroke-color: rgba(255, 255, 255, 1);
        text-shadow: 0px 0px 4px rgba(0, 0, 0, 1);
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="text">Loading location...</div>

    <script>
      (function() {
        'use strict';

        const params = new URLSearchParams(window.location.search);
        const pullKey = params.get("key");
        const apiKey = params.get("api_key");

        let geocoder;
        let lastGeocodeTime = 0;
        const geocodeInterval = 1500; // milliseconds

        // The desired output format, same as the original code
        const specificFormat = "${data.address ? data.address.text + ', ' : ''}${data.neighborhood ? data.neighborhood.text + ', ' : ''}${data.locality ? data.locality.text + ', ' : ''}${data.place ? data.place.text : ''}";

        function wrappedEval(textExpression, contextData) {
          let fn = Function(
            `"use strict"; var data = this;return (${textExpression})`
          );
          return fn.bind(contextData)();
        }

        // This function will be called by the Google Maps script once it's loaded
        function initGeocoder() {
          geocoder = new google.maps.Geocoder();
          startLocationListener();
        }
        
        // This function parses the Google Geocoder response into the format expected by the original code
        function parseGoogleAddress(results) {
            const context = {};
            if (!results || results.length === 0) {
                return context;
            }

            // A helper to find a specific component type
            const getComponent = (type) => results[0].address_components.find(comp => comp.types.includes(type));
            
            // Map Google's component types to the original context keys
            const country = getComponent('country');
            const region = getComponent('administrative_area_level_1');
            const postcode = getComponent('postal_code');
            const district = getComponent('administrative_area_level_2');
            const place = getComponent('locality'); // Google's 'locality' is typically the city/town
            const locality = getComponent('sublocality_level_1') || getComponent('sublocality'); // Google's 'sublocality' can be a district or large neighborhood
            const neighborhood = getComponent('neighborhood');

            // Construct an address from street number and route if available
            const streetNumber = getComponent('street_number');
            const route = getComponent('route');
            let address = null;
            if (streetNumber && route) {
                address = { text: `${streetNumber.long_name} ${route.long_name}` };
            } else if (results[0].formatted_address) {
                // As a fallback for address, use the first part of the formatted address
                address = { text: results[0].formatted_address.split(',')[0] };
            }

            // Populate the context object
            if (country) context.country = { text: country.long_name };
            if (region) context.region = { text: region.long_name };
            if (postcode) context.postcode = { text: postcode.long_name };
            if (district) context.district = { text: district.long_name };
            if (place) context.place = { text: place.long_name };
            if (locality) context.locality = { text: locality.long_name };
            if (neighborhood) context.neighborhood = { text: neighborhood.long_name };
            if (address) context.address = address;
            
            return context;
        }


        function startLocationListener() {
          if (!pullKey) {
            document.getElementById("text").innerText = "Error: 'key' parameter missing in URL.";
            return;
          }

          RealtimeIRL.forPullKey(pullKey).addLocationListener(function (location) {
            const currentTime = Date.now();
            
            if (currentTime - lastGeocodeTime > geocodeInterval) {
              lastGeocodeTime = currentTime;

              const latlng = {
                lat: location.latitude,
                lng: location.longitude,
              };

              geocoder.geocode({ location: latlng })
                .then((response) => {
                  const context = parseGoogleAddress(response.results);
                  
                  const result = wrappedEval(
                    "`" + specificFormat + "`",
                    context
                  );

                  // Clean up and display the result
                  const cleanedResult = result.replace(/,\s*$/, "").replace(/,\s*,/g, ',').replace(/^,\s*/, '');
                  if (cleanedResult && cleanedResult.trim() !== '') {
                    document.getElementById("text").innerText = cleanedResult;
                  } else {
                    document.getElementById("text").innerText = "Location not found...";
                  }
                })
                .catch((error) => {
                  console.error("Google Geocoding error:", error);
                  document.getElementById("text").innerText = "Error finding location.";
                });
            }
          });
        }

        // --- API Loading and Initialization ---
        if (!apiKey) {
          document.getElementById("text").innerText = "Error: 'api_key' parameter missing in URL.";
        } else {
          window.initGeocoder = initGeocoder;
          const script = document.createElement('script');
          script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initGeocoder`;
          script.async = true;
          script.defer = true;
          document.head.appendChild(script);
        }

      })();
    </script>
  </body>
</html>
