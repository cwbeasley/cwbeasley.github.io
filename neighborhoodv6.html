<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/@mapbox/mapbox-sdk/umd/mapbox-sdk.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@rtirl/api@latest/lib/index.min.js"></script>
    <script defer src="https://overlays.rtirl.com/indicator.js"></script> 
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans&display=swap" rel="stylesheet">
    <style>
      body {
        background-color: rgba(0, 0, 0, 0);
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      #text {
        color: rgba(223, 251, 38, 1);
        font-size: 46px;
        font-family: 'Open Sans', sans-serif;
        font-weight: normal;
        font-style: normal;
        transform: rotate(0deg);
        background-color: rgba(0, 0, 0, 0);
        border-color: rgba(223, 251, 38, 1);
        border-width: 0px;
        border-style: solid;
        text-align: center;
        border-radius: 0% 0% 0% 0%;
        padding: 0px;
        -webkit-text-stroke-width: 0px;
        -webkit-text-stroke-color: rgba(255, 255, 255, 1);
        text-shadow: 0px 0px 4px rgba(0, 0, 0, 1);
        width: 100%;
        /* Ensure text itself can be vertically centered if needed */
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%; /* Make #text take full height of body for vertical centering */
      }
    </style>
  </head>
  <body>
    <div id="text">Loading location...</div>

    <script>
      function wrappedEval(textExpression, contextData) {
        let fn = Function(
          `"use strict"; var data = this;return (${textExpression})`
        );
        return fn.bind(contextData)();
      }

      var mapboxClient = mapboxSdk({
        accessToken: "pk.eyJ1IjoiY3diZWFzbGV5IiwiYSI6ImNtYmE3cDhwcjAzNGQycnNhYWFwem0zNWsifQ.IpKDT3XxpNAbvwc8ovez3w",
      });

      var params = new URLSearchParams(window.location.search);
      var pullKey = params.get("key"); 

      // Hardcoded values for this specific setup
      var specificFormat = "${data.address ? data.address.text + ', ' : ''}${data.neighborhood ? data.neighborhood.text + ', ' : ''}${data.locality ? data.locality.text + ', ' : ''}${data.place ? data.place.text : ''}";
      var specificLang = "en"; // This is already a string, which is what v6 SDK expects

      let lastGeocodeTime = 0;
      const geocodeInterval = 1500; // 1500 milliseconds = 1.5 seconds

      if (!pullKey) {
        document.getElementById("text").innerText = "Error: Key missing from URL.";
        console.error("Pull key is missing from URL parameters.");
      } else {
        RealtimeIRL.forPullKey(pullKey).addLocationListener(function (location) {
          const currentTime = new Date().getTime();
          
          if (currentTime - lastGeocodeTime > geocodeInterval) {
            lastGeocodeTime = currentTime; 

            // Use mapboxClient.geocodingV6 and update parameters
            mapboxClient.geocodingV6 // Switched to geocodingV6
              .reverseGeocode({
                // v6 SDK expects longitude and latitude as separate properties
                longitude: location.longitude,
                latitude: location.latitude,
                language: specificLang, // v6 SDK expects language as a string
                // Optionally, you can specify types for v6 if needed, e.g.:
                // types: ["address", "neighborhood", "locality", "place"] 
              })
              .send()
              .then((response) => {
                var context = {};
                // Updated list of params for context; "poi" is removed as v6 Geocoding doesn't focus on it.
                // Your format string doesn't use POI, so this is fine.
                const featureParamsToExtract = [
                  "country", "region", "postcode", "district",
                  "place", "locality", "neighborhood", "address" 
                  // "secondary_address" is also available in v6 if needed
                ];

                for (var param of featureParamsToExtract) {
                  if (response.body && response.body.features) {
                    context[param] = response.body.features.find((feature) =>
                      feature.place_type && feature.place_type.includes(param)
                    );
                  } else {
                    context[param] = undefined;
                  }
                }
                
                var result = wrappedEval(
                  "`" + specificFormat + "`",
                  context
                );

                let cleanedResult = result.trim();
                // Clean up potential leading/trailing commas and multiple commas
                if (cleanedResult.startsWith(',')) cleanedResult = cleanedResult.substring(1).trim();
                if (cleanedResult.endsWith(',')) cleanedResult = cleanedResult.slice(0, -1).trim();
                cleanedResult = cleanedResult.replace(/,(\s*,)+/g, ',').replace(/,\s*$/, "");


                if (cleanedResult && !cleanedResult.includes("undefined") && cleanedResult.replace(/,/g, "").trim() !== "") { 
                  document.getElementById("text").innerText = cleanedResult;
                 } else {
                  document.getElementById("text").innerText = "Location details not found"; // More specific message
                 }
              })
              .catch(error => {
                  console.error("Mapbox Geocoding v6 error:", error);
                  document.getElementById("text").innerText = "Geocoding API Error";
              });
          }
        });
      }
    </script>
  </body>
</html>